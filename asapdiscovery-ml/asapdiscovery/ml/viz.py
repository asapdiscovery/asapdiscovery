import matplotlib.pyplot as plt
import pandas
import seaborn as sns


def plot_split_losses(
    pred_tracker_dict,
    out_fn=None,
    splits=["train", "val", "test"],
    loss_label="Loss",
    **kwargs
):
    """
    Plot overall losses per split by training epoch.

    Parameters
    ----------
    pred_tracker_dict : dict[str, TrainingPredictionTracker]
        Dict mapping labels to pred trackers
    out_fn : Path, optional
        Path to save plot to
    splits : list[str], default=["train", "val", "test"]
        Which splits to actually plot
    loss_label : str, default="Loss"
        What to label the y-axis of the plot
    kwargs : dict
        Anything else to pass directly to relplot
    """
    # Build overall DF
    all_dfs = []
    for lab, pred_tracker in pred_tracker_dict.items():
        df = pred_tracker.to_plot_df(agg_compounds=True, agg_losses=True)
        df["label"] = lab
        all_dfs.append(df)

    all_dfs = pandas.concat(all_dfs, ignore_index=True)

    # Subset
    all_dfs = all_dfs.loc[all_dfs["split"].isin(splits), :]

    if ("hue" not in kwargs) and ("style" not in kwargs):
        # Figure out styles
        if len(pred_tracker_dict) > 1:
            # More than one different experiment, so use color for experiment and style
            #  for split
            hue = "label"
            hue_order = list(pred_tracker_dict.keys())
            if len(splits) > 1:
                style = "split"
                style_order = splits
            else:
                style = None
                style_order = None
        else:
            hue = "split"
            hue_order = splits
            style = None
            style_order = None
    else:
        # Pull from kwargs
        hue = kwargs.pop("hue", None)
        hue_order = kwargs.pop("hue_order", None)
        style = kwargs.pop("style", None)
        style_order = kwargs.pop("style_order", None)

    # Make plot
    # fig = plt.figure(figsize=(7, 5))
    fg = sns.relplot(
        all_dfs,
        x="epoch",
        y="loss",
        hue=hue,
        style=style,
        hue_order=hue_order,
        style_order=style_order,
        kind="line",
        aspect=1.5,
        **kwargs
    )

    # Set axes
    fg.set_axis_labels("Training Epoch", loss_label)

    if out_fn:
        fg.savefig(out_fn, bbox_inches="tight", dpi=200)

    return fg


def plot_model_preds_scatter(
    pred_tracker_dict, stats_dict, out_fn=None, split="test", use_epoch=-1, **kwargs
):
    """
    Plot a scatterplot of experimental vs predicted values.

    Parameters
    ----------
    pred_tracker_dict : dict[str, TrainingPredictionTracker]
        Dict mapping labels to pred trackers
    stats_dict : dict
        Dict mapping lab -> pred stats (generated by
        pred_tracker.calculate_pred_statistics)
    out_fn : Path, optional
        Path to save plot to
    split : str, default="test"
        Which split to plot
    use_epoch : int, default=-1
        Which epoch of training to take predictions from. Set to -1 to use final epoch
    kwargs : dict
        Anything else to pass directly to relplot

    Returns
    -------
    """
    # Build overall DF
    all_dfs = []
    for lab, pred_tracker in pred_tracker_dict.items():
        df = pred_tracker.to_plot_df(agg_losses=True)
        df["label"] = lab
        all_dfs.append(df)

    all_dfs = pandas.concat(all_dfs, ignore_index=True)

    # Subset by split and epoch
    if use_epoch < 0:
        use_epoch = all_dfs["epoch"].max()
    # TODO Need to do this by model, otherwise we only get the model that trained for
    #  the longest. probably using groupby
    epoch_idx = all_dfs["epoch"] == use_epoch
    split_idx = all_dfs["split"] == split
    all_dfs = all_dfs.loc[epoch_idx & split_idx, :]

    # Set so the legend looks nicer
    legend_text_mapper = {
        -1: "Below Assay Range",
        0: "In Assay Range",
        1: "Above Assay Range",
    }
    all_dfs["Assay Range"] = list(map(legend_text_mapper.get, all_dfs["in_range"]))

    plt.rc("font", size=18)
    fg = sns.relplot(
        data=all_dfs,
        x="target",
        y="pred",
        col="label",
        style="Assay Range",
        markers={
            "Below Assay Range": "<",
            "In Assay Range": "o",
            "Above Assay Range": ">",
        },
        style_order=["Below Assay Range", "In Assay Range", "Above Assay Range"],
        facet_kws={"sharex": False, "sharey": False},
    )

    # Figure title
    fg.figure.subplots_adjust(top=0.8)
    fg.figure.suptitle("Test Set Predictions", fontweight="bold")

    # Axes bounds
    # min_val = loss_df.loc[:, ["target", "pred"]].values.flatten().min() - 0.5
    min_val = -0.5
    max_val = all_dfs.loc[:, ["target", "pred"]].values.flatten().max() + 0.5

    for ax in fg.axes[:, 0]:
        ax.set_ylabel("Predicted $\mathrm{pIC}_{50}$")
    for ax in fg.axes[-1, :]:
        ax.set_xlabel("Experimental $\mathrm{pIC}_{50}$")

    if out_fn:
        fg.savefig(out_fn, bbox_inches="tight", dpi=200)

    return fg
